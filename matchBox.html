<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Â•ßÂ§öÊØîÊ∂àÊ∂àÊ®Ç</title>
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- LIFF SDK -->
    <script charset="utf-8" src="https://static.line-scdn.net/liff/edge/2/sdk.js"></script>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&family=Roboto+Mono:wght@500&display=swap');
        body { 
            font-family: 'Inter', sans-serif; 
            user-select: none; 
            -webkit-user-select: none;
            /* Prevent pull-to-refresh on mobile */
            overscroll-behavior-y: contain;
        }
        
        .grid-cell {
            will-change: transform;
        }
        
        /* ËÆìÂúñÁâá‰∏çËÉΩË¢´ÊãñÊõ≥ */
        .grid-cell img {
            pointer-events: none; 
            -webkit-user-drag: none;
            width: 100%;
            height: 100%;
            object-fit: contain;
            filter: drop-shadow(0 4px 3px rgba(0,0,0,0.3)); 
        }
        
        .selected {
            transform: scale(1.15);
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.4);
            background-color: rgba(255,255,255,0.1);
            border-radius: 18px;
            z-index: 20 !important;
        }

        /* Ê∂àÈô§ÂãïÁï´ */
        .match-anim {
            animation: popOut 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
            z-index: 10;
        }

        @keyframes popOut {
            0% { transform: scale(1); opacity: 1; filter: brightness(1); }
            40% { transform: scale(1.4); opacity: 0.9; filter: brightness(1.5); }
            100% { transform: scale(0); opacity: 0; filter: brightness(1); }
        }

        /* ËºïÂæÆÊôÉÂãïÊïàÊûú */
        .shake-anim {
            animation: shake 0.3s ease-in-out;
        }
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }

        /* ÂäáÁÉàÊôÉÂãï */
        .shake-intense {
            animation: shakeIntense 0.2s infinite;
        }
        @keyframes shakeIntense {
            0% { transform: translate(0, 0) rotate(0deg); }
            25% { transform: translate(-3px, 3px) rotate(-5deg); }
            50% { transform: translate(3px, -3px) rotate(5deg); }
            75% { transform: translate(-3px, -3px) rotate(-5deg); }
            100% { transform: translate(3px, 3px) rotate(5deg); }
        }

        /* ÈÄ£ÈéñÈúáÂãï */
        .screen-shake-combo {
            animation: screenShake 0.3s ease-in-out;
        }
        @keyframes screenShake {
            0% { transform: translate(0, 0); }
            20% { transform: translate(-5px, 5px); }
            40% { transform: translate(5px, -5px); }
            60% { transform: translate(-5px, -5px); }
            80% { transform: translate(5px, 5px); }
            100% { transform: translate(0, 0); }
        }
        
        /* Á•ûÁ•ïÊñπÂ°äËÑàË°ù */
        .mystery-pulse {
            animation: mysteryPulse 1.5s infinite;
        }
        @keyframes mysteryPulse {
            0% { filter: drop-shadow(0 0 2px #fff); transform: scale(1); }
            50% { filter: drop-shadow(0 0 8px #D29BFF); transform: scale(1.02); }
            100% { filter: drop-shadow(0 0 2px #fff); transform: scale(1); }
        }

        /* ÁÇ∏ÂΩàËÑàË°ù */
        .bomb-pulse {
            animation: bombPulse 1s infinite;
        }
        @keyframes bombPulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); filter: brightness(1.2); }
            100% { transform: scale(1); }
        }

        /* ÁÇ∏ÂΩàË∂Ö‰∫∫ÁÅ´ÁÑ∞ÁâπÊïà */
        .explosion-fire {
            background: radial-gradient(circle, #fff700 10%, #ff8800 50%, #ff0000 90%);
            border-radius: 8px;
            animation: fireExpand 0.4s ease-out forwards;
            box-shadow: 0 0 15px #ff4500;
            z-index: 50;
        }
        @keyframes fireExpand {
            0% { transform: scale(0.5); opacity: 0.8; }
            50% { transform: scale(1.2); opacity: 1; }
            100% { transform: scale(1); opacity: 0; }
        }

        /* Combo ÊñáÂ≠óÁâπÊïà */
        .combo-text-anim {
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            font-size: 4rem;
            font-weight: 900;
            color: #FFFF00;
            text-shadow: 4px 4px 0px #FF0000, 0 0 20px rgba(255, 165, 0, 0.8);
            font-family: 'Inter', sans-serif;
            font-style: italic;
            z-index: 100;
            pointer-events: none;
            white-space: nowrap;
            animation: comboFloat 0.8s ease-out forwards;
        }
        @keyframes comboFloat {
            0% { transform: translate(-50%, -50%) scale(0.5) rotate(-10deg); opacity: 0; }
            30% { transform: translate(-50%, -50%) scale(1.2) rotate(0deg); opacity: 1; }
            100% { transform: translate(-50%, -150%) scale(1) rotate(0deg); opacity: 0; }
        }

        /* Custom Scrollbar */
        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: #1f2937; }
        ::-webkit-scrollbar-thumb { background: #4b5563; border-radius: 3px; }
        ::-webkit-scrollbar-thumb:hover { background: #6b7280; }
        
        #leaderboard-section {
            transition: height 0.3s ease-in-out;
        }

        /* Prevent scrolling on game grid for swipe gestures */
        #game-grid {
            touch-action: none; 
        }
    </style>
</head>
<body class="bg-gray-900 text-white min-h-screen flex flex-col items-center justify-center overflow-hidden">

    <!-- Fireworks Canvas (Overlay) -->
    <canvas id="fireworks-canvas" class="fixed inset-0 pointer-events-none z-50"></canvas>

    <!-- App Container -->
    <div id="app" class="w-full max-w-5xl h-screen md:h-auto md:min-h-[850px] flex flex-col md:flex-row gap-6 p-4 relative">
        
        <!-- Game Section -->
        <div id="game-container" class="flex-1 flex flex-col items-center justify-center bg-gray-800 rounded-3xl p-6 shadow-2xl border border-gray-700 relative overflow-hidden z-10 transition-transform">
            
            <!-- Tip Ticker (Marquee Style) -->
            <div id="tip-container" class="w-full bg-gray-900/60 rounded-lg mb-4 flex items-center min-h-[40px] border border-gray-700/50 backdrop-blur-sm overflow-hidden relative">
                <div id="tip-content" class="absolute top-1/2 -translate-y-1/2 whitespace-nowrap text-sm md:text-base text-gray-200 font-medium will-change-transform">
                    <!-- Text will be injected here -->
                </div>
            </div>

            <!-- Header / Stats (Fixed Layout) -->
            <div class="w-full flex items-end justify-between mb-4 px-1 gap-2 md:gap-4">
                <!-- Left: Score & Level -->
                <div class="flex flex-col flex-shrink-0">
                    <span class="text-[10px] md:text-xs text-gray-400 uppercase tracking-wider mb-1">SCORE / LEVEL</span>
                    <div class="flex items-baseline gap-1 md:gap-2">
                        <span id="score-display" class="text-3xl md:text-4xl font-black text-transparent bg-clip-text bg-gradient-to-r from-yellow-400 to-orange-500 font-mono">0</span>
                        <span class="text-xs md:text-sm text-gray-500 font-bold">LV.<span id="level-display">1</span></span>
                    </div>
                </div>

                <!-- Middle: Progress Bar (Responsive) -->
                <div class="flex-1 flex flex-col justify-end pb-2 px-2 md:px-4 min-w-[60px]">
                     <div class="flex justify-between text-[10px] text-gray-400 mb-1">
                        <span>EXP</span>
                        <span id="progress-percent">0%</span>
                     </div>
                     <div class="w-full bg-gray-700 h-1.5 md:h-2 rounded-full overflow-hidden border border-gray-600">
                        <div id="level-progress" class="bg-blue-500 h-full w-0 transition-all duration-500 shadow-[0_0_10px_rgba(59,130,246,0.5)]"></div>
                     </div>
                </div>

                <!-- Right: Time -->
                <div class="flex flex-col items-end flex-shrink-0">
                    <span class="text-[10px] md:text-xs text-gray-400 uppercase tracking-wider mb-1">TIME</span>
                    <span id="time-display" class="text-3xl md:text-4xl font-black text-red-400 font-mono drop-shadow-lg">60</span>
                </div>
            </div>

            <!-- Game Board Wrapper -->
            <div class="relative bg-gray-900/50 p-2 md:p-3 rounded-2xl border border-gray-700/50 shadow-inner backdrop-blur-sm">
                <!-- Flash Overlay for Mystery/Bomb Clear -->
                <div id="flash-overlay" class="absolute inset-0 pointer-events-none z-20 rounded-2xl"></div>

                <div id="game-grid" class="grid grid-cols-8 gap-1 md:gap-1.5 w-[320px] h-[320px] sm:w-[420px] sm:h-[420px] md:w-[520px] md:h-[520px] relative">
                    <!-- Tiles injected by JS -->
                </div>
                
                <!-- Overlay: Game Over / Start -->
                <div id="overlay" class="absolute inset-0 bg-gray-900/95 z-30 flex flex-col items-center justify-center rounded-2xl backdrop-blur-md transition-opacity duration-300 px-4">
                    <div class="text-center mb-6 md:mb-8 transform hover:scale-105 transition duration-500">
                        <h1 class="text-4xl md:text-6xl font-black text-transparent bg-clip-text bg-gradient-to-r from-[#FF0000] via-[#D29BFF] to-[#31A8FF] mb-2 drop-shadow-2xl font-[sans-serif]">
                            Â•ßÂ§öÊØî<br>Ê∂àÊ∂àÊ®Ç
                        </h1>
                        <p class="text-gray-400 text-xs md:text-sm tracking-[0.2em] uppercase">Creative Cloud Edition</p>
                    </div>
                    
                    <div id="start-screen-content" class="flex flex-col items-center w-full px-4 space-y-4">
                        <input type="text" id="player-name-input" placeholder="Ëº∏ÂÖ•ÊÇ®ÁöÑÊö±Á®±" class="w-full max-w-xs bg-gray-800 border border-gray-600 text-white text-center rounded-xl px-4 py-4 focus:outline-none focus:border-blue-500 focus:ring-2 focus:ring-blue-500/50 placeholder-gray-500 transition-all text-lg">
                        <button id="start-btn" class="w-full max-w-xs bg-gradient-to-r from-blue-600 to-indigo-600 hover:from-blue-500 hover:to-indigo-500 text-white font-bold py-4 px-6 rounded-xl transform transition active:scale-95 shadow-lg shadow-blue-900/30 flex items-center justify-center gap-2 group">
                            <span>ÈñãÂßãÈÅäÊà≤</span>
                            <svg class="w-5 h-5 group-hover:translate-x-1 transition-transform" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14.752 11.168l-3.197-2.132A1 1 0 0010 9.87v4.263a1 1 0 001.555.832l3.197-2.132a1 1 0 000-1.664z"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
                        </button>
                    </div>

                    <div id="game-over-content" class="hidden flex flex-col items-center w-full text-center animate-in fade-in zoom-in duration-300 overflow-y-auto max-h-full py-4">
                        <p class="text-3xl font-bold text-white mb-2">ÈÅäÊà≤ÁµêÊùüÔºÅ</p>
                        <div class="bg-gray-800/80 p-6 rounded-xl border border-gray-600 mb-4 w-full max-w-xs">
                            <p class="text-sm text-gray-400 mb-1">ÊúÄÁµÇÂæóÂàÜ</p>
                            <p class="text-4xl text-yellow-400 font-mono font-bold tracking-tight"><span id="final-score">0</span></p>
                        </div>
                        
                        <div class="flex flex-col gap-3 w-full max-w-xs">
                            <button id="restart-btn" class="w-full bg-white hover:bg-gray-100 text-gray-900 font-bold py-3 px-8 rounded-xl border border-gray-200 transition shadow-lg active:scale-95">
                                ÂÜçÁé©‰∏ÄÊ¨°
                            </button>
                            
                            <!-- Share Button (Updated: No Icon) -->
                            <button id="share-btn" class="w-full flex items-center justify-center gap-2 bg-[#06C755] hover:bg-[#05b34c] text-white font-bold py-3 px-8 rounded-xl transition shadow-lg active:scale-95 border border-[#06C755]/50 group">
                                ÂàÜ‰∫´Â•ΩÂèã
                            </button>

                            <!-- Reward Button (Initially Hidden) -->
                            <button id="reward-btn" class="hidden w-full flex items-center justify-center gap-2 bg-gradient-to-r from-yellow-500 to-orange-500 hover:from-yellow-400 hover:to-orange-400 text-black font-bold py-3 px-8 rounded-xl transition shadow-lg active:scale-95 border border-yellow-300">
                                <span class="text-xl">üéÅ</span> È†òÂèñÈÄöÈóúÁçéÂãµ
                            </button>
                        </div>
                    </div>
                </div>

                <!-- Level Up Notification -->
                <div id="level-up-toast" class="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 pointer-events-none opacity-0 z-20 transition-all duration-500">
                    <div class="bg-gradient-to-r from-yellow-400 to-orange-500 text-black font-black text-4xl px-8 py-4 rounded-xl shadow-2xl rotate-[-5deg] border-4 border-white whitespace-nowrap">
                        LEVEL UP!
                    </div>
                </div>
            </div>
            
            <!-- Controls Hint -->
            <div class="mt-4 flex gap-4 text-xs text-gray-500 justify-center">
                <div class="flex items-center gap-1"><span class="w-2 h-2 rounded-full bg-blue-500"></span> ‰∫§Êèõ</div>
                <div class="flex items-center gap-1"><span class="w-2 h-2 rounded-full bg-yellow-400"></span> ÈÄ£Á∑ö</div>
                <div class="flex items-center gap-1"><span class="w-2 h-2 rounded-full bg-indigo-600 border border-gray-600">?</span> È©öÂñú</div>
                <div class="flex items-center gap-1"><span class="w-2 h-2 rounded-full bg-black border border-gray-600">üí£</span> ÁÇ∏ÂΩà</div>
            </div>
        </div>

        <!-- Leaderboard Section (Local) -->
        <div id="leaderboard-section" class="w-full md:w-80 bg-gray-800 rounded-3xl shadow-2xl border border-gray-700 flex flex-col overflow-hidden h-14 md:h-auto z-20 absolute bottom-4 left-4 right-4 md:relative md:bottom-auto md:left-auto md:right-auto md:block">
            <!-- Header (Clickable on Mobile) -->
            <div id="leaderboard-header" class="p-4 flex justify-between items-center cursor-pointer md:cursor-default bg-gray-800 border-b border-gray-700 md:border-none">
                <h2 class="text-lg font-bold flex items-center gap-2 text-white">
                    <span class="text-2xl">üèÜ</span> Êú¨Ê©üÁ¥ÄÈåÑ
                </h2>
                <!-- Toggle Icon (Mobile Only) -->
                <button class="md:hidden text-gray-400 focus:outline-none">
                    <svg id="chevron-icon" class="w-6 h-6 transform transition-transform duration-300" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 15l7-7 7 7"></path>
                    </svg>
                </button>
            </div>

            <!-- List Content -->
            <div id="leaderboard-content" class="flex-1 overflow-y-auto space-y-2 px-6 pb-6 pt-2 bg-gray-800 hidden md:block opacity-0 md:opacity-100 transition-opacity duration-300">
                <div id="leaderboard-list" class="space-y-2">
                    <!-- Leaderboard items injected here -->
                    <div class="text-center text-gray-500 py-4 animate-pulse">ËºâÂÖ•Á¥ÄÈåÑ...</div>
                </div>
            </div>
        </div>

    </div>

    <!-- Main Logic -->
    <script>
        // --- LIFF & App Config ---
        const LIFF_ID = "2008592497-pvgkXmM2";
        const LOCAL_STORAGE_KEY = "adobe_match_scores_v1";

        // --- Game Config ---
        const GRID_SIZE = 8;
        const BASE_TIME = 60;
        const LEVEL_THRESHOLD = 800; 
        const FIREWORKS_THRESHOLD = 10000;

        // --- Icons Data ---
        const ALL_TILES = [
            { id: 'Ps', name: 'Photoshop', file: 'Adobe_Photoshop_CC_icon.svg' },
            { id: 'Ai', name: 'Illustrator', file: 'Adobe_Illustrator_CC_icon.svg' },
            { id: 'Ac', name: 'Acrobat', file: 'Adobe_Acrobat_DC_logo_2020.svg' },
            { id: 'Fl', name: 'Firefly', file: 'Adobe_Firefly_Logo.svg' },
            { id: 'Ex', name: 'Express', file: 'Adobe_Express_logo_CMYK_256px.svg' },
            { id: 'Lr', name: 'Lightroom', file: 'Adobe_Photoshop_Lightroom_CC_logo.svg' },
            { id: 'Pr', name: 'Premiere', file: 'Adobe_Premiere_Pro_CC_icon.svg' },
            { id: 'Ae', name: 'After Effects', file: 'Adobe_After_Effects_CC_icon.svg'},
            { id: 'CC', name: 'Creative Cloud', file: 'Adobe_Creative_Cloud_rainbow_icon.svg'}
        ];

        // --- Tips Data ---
        const ADOBE_TIPS = [
            "üí° Ps Â∞èÊäÄÂ∑ßÔºöÊåâ‰Ωè Space ÈçµÂèØ‰ª•Èö®ÊôÇÂàáÊèõÊàêÊâãÂûãÂ∑•ÂÖ∑ÁßªÂãïÁï´Èù¢„ÄÇ",
            "üí° Ai ÂÜ∑Áü•Ë≠òÔºöCtrl + D ÂèØ‰ª•ÈáçË§á‰∏ä‰∏ÄÂÄãËÆäÂΩ¢Âãï‰ΩúÔºåË£Ω‰ΩúÈáçË§áÂúñÊ®£Ë∂ÖÊñπ‰æøÔºÅ",
            "üí° Pr ÂØÜÊäÄÔºöÊåâ Q Âíå W ÂèØ‰ª•Âø´ÈÄüË£ÅÂâ™Ê≥¢Á¥ãÁ∑®ËºØÔºåÂâ™ËºØÈÄüÂ∫¶ÂÄçÂ¢û„ÄÇ",
            "üí° Ae ÊèêÈÜíÔºöÈñãÂïüÂãïÊÖãÊ®°Á≥ä (Motion Blur) ÈñãÈóúÔºåËÆìÁßªÂãïÁöÑÂúñÂ±§ÁúãËµ∑‰æÜÊõ¥Ëá™ÁÑ∂„ÄÇ",
            "üí° Lr ÊäÄÂ∑ßÔºöÂú®Á∑®ËºØÊ®°Âºè‰∏ãÊåâ \\ ÈçµÔºåÂèØ‰ª•Âø´ÈÄüÊØîÂ∞ç‰øÆÊîπÂâçÂæåÁöÑÂ∑ÆÁï∞„ÄÇ",
            "üí° AcrobatÔºöÊâãÊ©ü‰∏ãËºâ Acrobat Reader AppÔºåÂèØ‰ª•ÊãçÁÖßÁõ¥Êé•ÊéÉÊèèÊàê PDF„ÄÇ",
            "üí° FireflyÔºö‰ΩøÁî® Generative Fill (ÁîüÊàêÂ°´Ëâ≤) ÂèØ‰ª•Âø´ÈÄüÊì¥Â±ïÂúñÁâáËÉåÊôØ„ÄÇ",
            "üí° CC Èõ≤Á´ØÔºöÂñÑÁî® CC LibraryÔºåÂèØ‰ª•Âú®‰∏çÂêåËªüÈ´îÈñìÁßíÈÄüÂêåÊ≠•È°èËâ≤ÂíåLogo„ÄÇ",
            "üí° ExpressÔºö‰∏ÄÈçµ„ÄåÁßªÈô§ËÉåÊôØ„ÄçÂäüËÉΩÈùûÂ∏∏Âº∑Â§ßÔºåÈÅ©ÂêàË£Ω‰ΩúÁ§æÁæ§Ë≤ºÊñá„ÄÇ",
            "‚ùì Q: Photoshop ÁöÑÈ†êË®≠Â≠òÊ™îÊ†ºÂºèÊòØ‰ªÄÈ∫ºÔºü A: PSD",
            "‚ùì Q: Âì™ÂÄãËªüÈ´îÊúÄÈÅ©ÂêàËôïÁêÜÂêëÈáèÂúñÂΩ¢Ôºü A: Illustrator",
            "üí° Ps ÊäÄÂ∑ßÔºöÊåâ‰Ωè Alt ÈçµÊãñÊõ≥ÂúñÂ±§ÔºåÂèØ‰ª•Âø´ÈÄüË§áË£ΩË©≤ÂúñÂ±§„ÄÇ",
            "üí° Ai ÊäÄÂ∑ßÔºö‰ΩøÁî®ÂΩ¢ÁãÄÂª∫Á´ãÁ®ãÂºèÂ∑•ÂÖ∑ (Shift+M) ÂèØ‰ª•Âø´ÈÄüÂêà‰ΩµÊàñÂà™Èô§ÈáçÁñäÂçÄÂüü„ÄÇ"
        ];
        
        // --- State ---
        let grid = []; 
        let score = 0;
        let timeLeft = BASE_TIME;
        let gameInterval = null;
        let isProcessing = false;
        let selectedTile = null; 
        let playerName = "Designer";
        let currentLevel = 1;
        let activeTileCount = 5; 
        let isLeaderboardOpen = false;
        let hasWonFireworks = false;

        // Swipe Handling
        let touchStartX = 0;
        let touchStartY = 0;
        let touchEndX = 0;
        let touchEndY = 0;

        // --- Audio Context ---
        let audioCtx = null;
        let gainNode = null;

        // --- DOM Elements ---
        const gameContainer = document.getElementById('game-container');
        const gridEl = document.getElementById('game-grid');
        const scoreEl = document.getElementById('score-display');
        const levelEl = document.getElementById('level-display');
        const levelProgressEl = document.getElementById('level-progress');
        const progressPercentEl = document.getElementById('progress-percent');
        const timeEl = document.getElementById('time-display');
        const overlayEl = document.getElementById('overlay');
        const startScreenContent = document.getElementById('start-screen-content');
        const gameOverContent = document.getElementById('game-over-content');
        const finalScoreEl = document.getElementById('final-score');
        const nameInput = document.getElementById('player-name-input');
        const startBtn = document.getElementById('start-btn');
        const restartBtn = document.getElementById('restart-btn');
        const shareBtn = document.getElementById('share-btn'); 
        const rewardBtn = document.getElementById('reward-btn'); 
        const leaderboardList = document.getElementById('leaderboard-list');
        const levelUpToast = document.getElementById('level-up-toast');
        const flashOverlay = document.getElementById('flash-overlay');
        const fireworksCanvas = document.getElementById('fireworks-canvas');
        
        // Tip Elements
        const tipContainer = document.getElementById('tip-container');
        const tipContent = document.getElementById('tip-content');
        
        // Leaderboard Toggle Elements
        const leaderboardSection = document.getElementById('leaderboard-section');
        const leaderboardHeader = document.getElementById('leaderboard-header');
        const leaderboardContent = document.getElementById('leaderboard-content');
        const chevronIcon = document.getElementById('chevron-icon');

        // --- LIFF Initialization ---
        async function initLiff() {
            try {
                await liff.init({ liffId: LIFF_ID });
                if (!liff.isLoggedIn()) {
                    // Optional: liff.login(); or just allow guest play
                    // console.log("User not logged in");
                }
            } catch (err) {
                console.error("LIFF Init Error", err);
            }
        }

        // --- Audio System ---
        function initAudio() {
            if (!audioCtx) {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                gainNode = audioCtx.createGain();
                gainNode.connect(audioCtx.destination);
                gainNode.gain.value = 0.3; // Master volume
            }
            if (audioCtx.state === 'suspended') {
                audioCtx.resume();
            }
        }

        function playTone(freq, type, duration, startTime = 0) {
            if (!audioCtx) return;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.type = type;
            osc.frequency.setValueAtTime(freq, audioCtx.currentTime + startTime);
            gain.gain.setValueAtTime(0.3, audioCtx.currentTime + startTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + startTime + duration);
            osc.connect(gain);
            gain.connect(gainNode);
            osc.start(audioCtx.currentTime + startTime);
            osc.stop(audioCtx.currentTime + startTime + duration);
        }

        function playSwapSound() { playTone(300, 'sine', 0.1); }
        function playInvalidSound() { playTone(150, 'sawtooth', 0.1); setTimeout(() => playTone(100, 'sawtooth', 0.1), 100); }
        function playMatchSound(comboLevel = 0) {
            const baseFreqs = [523.25, 587.33, 659.25, 783.99, 880.00, 1046.50, 1174.66, 1318.51];
            const pitchIndex = Math.min(comboLevel, baseFreqs.length - 1);
            const freq = baseFreqs[pitchIndex];
            playTone(freq, 'sine', 0.2);
            playTone(freq * 2, 'sine', 0.2, 0.05);
            if (comboLevel > 1) {
                setTimeout(() => playTone(freq * 1.5, 'square', 0.1), 50);
            }
        }
        function playLevelUpSound() {
            playTone(440, 'square', 0.1, 0);
            playTone(554, 'square', 0.1, 0.1);
            playTone(659, 'square', 0.2, 0.2);
            playTone(880, 'square', 0.4, 0.3);
        }
        function playMysterySound() {
            if (!audioCtx) return;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.frequency.setValueAtTime(200, audioCtx.currentTime);
            osc.frequency.linearRampToValueAtTime(800, audioCtx.currentTime + 2); 
            gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
            gain.gain.linearRampToValueAtTime(0.5, audioCtx.currentTime + 1.8);
            gain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 2);
            osc.connect(gain);
            gain.connect(gainNode);
            osc.start();
            osc.stop(audioCtx.currentTime + 2);
        }
        function playBombSound() {
            if (!audioCtx) return;
            const noiseBuffer = audioCtx.createBuffer(1, audioCtx.sampleRate * 0.5, audioCtx.sampleRate);
            const output = noiseBuffer.getChannelData(0);
            for (let i = 0; i < noiseBuffer.length; i++) output[i] = Math.random() * 2 - 1;
            const noiseSrc = audioCtx.createBufferSource();
            noiseSrc.buffer = noiseBuffer;
            const noiseGain = audioCtx.createGain();
            noiseGain.gain.setValueAtTime(0.2, audioCtx.currentTime);
            noiseGain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.5);
            noiseSrc.connect(noiseGain);
            noiseGain.connect(gainNode);
            noiseSrc.start();
            setTimeout(() => {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(100, audioCtx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(10, audioCtx.currentTime + 0.5);
                gain.gain.setValueAtTime(1, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.5);
                osc.connect(gain);
                gain.connect(gainNode);
                osc.start(audioCtx.currentTime);
                osc.stop(audioCtx.currentTime + 0.5);
            }, 400);
        }
        function playMassiveClearSound() {
            playTone(100, 'sawtooth', 0.5);
            playTone(200, 'sine', 0.5);
            setTimeout(() => playTone(800, 'square', 0.3), 100);
        }

        // --- Fireworks System ---
        const particles = [];
        let fireworksLoop = null;

        function createFirework() {
            const x = Math.random() * fireworksCanvas.width;
            const y = Math.random() * (fireworksCanvas.height / 2); 
            const color = `hsl(${Math.random() * 360}, 100%, 50%)`;
            
            for (let i = 0; i < 50; i++) {
                const angle = Math.random() * Math.PI * 2;
                const velocity = Math.random() * 4 + 1;
                particles.push({
                    x: x,
                    y: y,
                    vx: Math.cos(angle) * velocity,
                    vy: Math.sin(angle) * velocity,
                    life: 1,
                    color: color,
                    decay: Math.random() * 0.02 + 0.01
                });
            }
        }

        function drawFireworks() {
            if (fireworksCanvas.width !== window.innerWidth || fireworksCanvas.height !== window.innerHeight) {
                fireworksCanvas.width = window.innerWidth;
                fireworksCanvas.height = window.innerHeight;
            }
            const ctx = fireworksCanvas.getContext('2d');
            ctx.globalCompositeOperation = 'destination-out';
            ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
            ctx.fillRect(0, 0, fireworksCanvas.width, fireworksCanvas.height);
            ctx.globalCompositeOperation = 'lighter';

            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.vy += 0.05; // Gravity
                p.life -= p.decay;
                
                ctx.beginPath();
                ctx.arc(p.x, p.y, 3, 0, Math.PI * 2);
                ctx.fillStyle = p.color;
                ctx.globalAlpha = p.life;
                ctx.fill();

                if (p.life <= 0) {
                    particles.splice(i, 1);
                }
            }

            if (Math.random() < 0.05) {
                createFirework();
                playTone(200 + Math.random() * 600, 'square', 0.1);
            }

            fireworksLoop = requestAnimationFrame(drawFireworks);
        }

        function startFireworks() {
            fireworksCanvas.width = window.innerWidth;
            fireworksCanvas.height = window.innerHeight;
            drawFireworks();
            setTimeout(() => {
                cancelAnimationFrame(fireworksLoop);
                const ctx = fireworksCanvas.getContext('2d');
                ctx.clearRect(0, 0, fireworksCanvas.width, fireworksCanvas.height);
            }, 10000);
        }

        // --- Icon Generation ---
        function getIconSVG(tileData) {
            if (!tileData) return ''; 
            
            // MYSTERY TILE VISUAL
            if (tileData.id === 'Mystery') {
                return `
                    <svg viewBox="0 0 100 100" class="w-full h-full drop-shadow-md mystery-pulse">
                        <defs>
                            <linearGradient id="mysteryGrad" x1="0%" y1="0%" x2="100%" y2="100%">
                                <stop offset="0%" style="stop-color:#4f46e5;stop-opacity:1" />
                                <stop offset="100%" style="stop-color:#7e22ce;stop-opacity:1" />
                            </linearGradient>
                        </defs>
                        <rect x="5" y="5" width="90" height="90" rx="22" fill="url(#mysteryGrad)" />
                        <text x="50" y="65" font-family="sans-serif" font-weight="900" font-size="55" text-anchor="middle" fill="white" style="filter: drop-shadow(0px 2px 4px rgba(0,0,0,0.5));">?</text>
                        <!-- Gloss similar to official icons -->
                        <path d="M10 25 Q 50 5 90 25" stroke="white" stroke-opacity="0.2" stroke-width="3" fill="none" />
                    </svg>
                `;
            }
            
            // BOMB TILE VISUAL (Updated to SVG)
            if (tileData.id === 'Bomb') {
                return `
                    <svg viewBox="0 0 100 100" class="w-full h-full drop-shadow-md bomb-pulse">
                        <defs>
                            <radialGradient id="bombGrad" cx="30%" cy="30%" r="80%">
                                <stop offset="0%" style="stop-color:#4b5563;stop-opacity:1" />
                                <stop offset="100%" style="stop-color:#000000;stop-opacity:1" />
                            </radialGradient>
                        </defs>
                        <rect x="5" y="5" width="90" height="90" rx="22" fill="url(#bombGrad)" stroke="rgba(255,255,255,0.1)" stroke-width="2" />
                        <text x="50" y="65" font-family="sans-serif" font-size="50" text-anchor="middle" style="filter: drop-shadow(0 0 5px red);">üí£</text>
                        <path d="M10 25 Q 50 5 90 25" stroke="white" stroke-opacity="0.1" stroke-width="3" fill="none" />
                    </svg>
                `;
            }

            const { id, file, name } = tileData;
            const baseUrl = "https://commons.wikimedia.org/wiki/Special:FilePath/";
            const fullUrl = baseUrl + file;

            return `
                <img src="${fullUrl}" 
                     alt="${name}" 
                     class="w-full h-full object-contain pointer-events-none drop-shadow-md"
                     onerror="this.onerror=null; this.src='data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIj48cmVjdCB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCIgZmlsbD0iIzMzMyIvPjx0ZXh0IHg9IjUwIiB5PSI1NSIgZmlsbD0id2hpdGUiIHRleHQtYW5jaG9yPSJtaWRkbGUiPj88L3RleHQ+PC9zdmc+'">
            `;
        }

        // --- Helper: Get random tile based on active count ---
        function getRandomTile() {
            const rand = Math.random();
            if (rand < 0.05) {
                return { id: 'Mystery', name: 'Mystery Box' };
            }
            if (rand < 0.08) {
                return { id: 'Bomb', name: 'Bomb' };
            }
            const index = Math.floor(Math.random() * activeTileCount);
            return ALL_TILES[index];
        }

        // --- Tips Ticker Logic ---
        function startTipsTicker() {
            let tickerTimeout;
            const runTicker = () => {
                const randomTip = ADOBE_TIPS[Math.floor(Math.random() * ADOBE_TIPS.length)];
                tipContent.innerText = randomTip;
                tipContent.style.transition = 'none';
                tipContent.style.left = '100%'; 
                void tipContent.offsetWidth;
                const totalDistance = tipContainer.offsetWidth + tipContent.offsetWidth;
                const speed = 100; 
                const duration = Math.max(8, totalDistance / speed * 4); 
                tipContent.style.transition = `left ${duration}s linear`;
                tipContent.style.left = `-${tipContent.offsetWidth}px`;
                if (tickerTimeout) clearTimeout(tickerTimeout);
                tickerTimeout = setTimeout(runTicker, duration * 1000); 
            };
            runTicker();
        }

        // --- Local Leaderboard Logic ---
        function updateLocalLeaderboard(newScore) {
            if (newScore === 0) return;
            
            // Get existing
            let scores = JSON.parse(localStorage.getItem(LOCAL_STORAGE_KEY) || '[]');
            
            // Add new
            scores.push({
                name: playerName,
                score: newScore,
                timestamp: Date.now(),
                level: currentLevel
            });
            
            // Sort
            scores.sort((a, b) => b.score - a.score);
            
            // Keep top 5
            scores = scores.slice(0, 5);
            
            // Save
            localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(scores));
            
            renderLeaderboardHTML(scores);
        }

        function loadLocalLeaderboard() {
            const scores = JSON.parse(localStorage.getItem(LOCAL_STORAGE_KEY) || '[]');
            renderLeaderboardHTML(scores);
        }

        function renderLeaderboardHTML(scores) {
            if (scores.length === 0) {
                leaderboardList.innerHTML = '<div class="text-center text-gray-500 py-4">Êö´ÁÑ°Á¥ÄÈåÑÔºåÂø´‰æÜÊåëÊà∞ÔºÅ</div>';
                return;
            }
            leaderboardList.innerHTML = scores.map((s, index) => {
                let rankClass = "text-gray-400";
                let rankIcon = "";
                
                if (index === 0) { rankClass = "text-yellow-400 font-bold"; rankIcon = "üëë"; }
                else if (index === 1) { rankClass = "text-gray-300 font-bold"; }
                else if (index === 2) { rankClass = "text-amber-600 font-bold"; }

                const dateStr = s.timestamp ? new Date(s.timestamp).toLocaleDateString() : '';

                return `
                    <div class="flex justify-between items-center bg-gray-700/50 p-2 rounded hover:bg-gray-700 transition">
                        <div class="flex items-center gap-3">
                            <span class="w-6 text-center ${rankClass}">${index + 1}</span>
                            <div class="flex flex-col">
                                <span class="text-sm font-medium text-white truncate max-w-[100px]">${s.name || 'Anonymous'}</span>
                                <span class="text-[10px] text-gray-500">${dateStr}</span>
                            </div>
                        </div>
                        <span class="font-mono text-yellow-400 font-bold">${s.score}</span>
                    </div>
                `;
            }).join('');
        }

        // --- Game Logic ---
        function initGame() {
            score = 0;
            timeLeft = BASE_TIME;
            currentLevel = 1;
            activeTileCount = 5; 
            hasWonFireworks = false;
            
            scoreEl.innerText = score;
            timeEl.innerText = timeLeft;
            levelEl.innerText = currentLevel;
            updateProgressBar();
            
            grid = [];
            gridEl.innerHTML = '';
            selectedTile = null;
            isProcessing = false;

            createBoard();
            cleanInitialBoard();
            startTipsTicker();
            loadLocalLeaderboard();

            overlayEl.classList.add('hidden');
            startScreenContent.classList.add('hidden');
            gameOverContent.classList.add('hidden');
            
            // Reset Buttons visibility
            rewardBtn.classList.add('hidden');

            if (gameInterval) clearInterval(gameInterval);
            gameInterval = setInterval(() => {
                timeLeft--;
                timeEl.innerText = timeLeft;
                if (timeLeft <= 0) endGame();
                else if (timeLeft <= 10) timeEl.classList.add('animate-pulse', 'text-red-500');
            }, 1000);
            
            initAudio(); 
        }

        function updateProgressBar() {
            const nextLevelScore = currentLevel * LEVEL_THRESHOLD;
            const prevLevelScore = (currentLevel - 1) * LEVEL_THRESHOLD;
            const percentage = Math.min(100, Math.max(0, ((score - prevLevelScore) / (nextLevelScore - prevLevelScore)) * 100));
            levelProgressEl.style.width = `${percentage}%`;
            progressPercentEl.innerText = `${Math.floor(percentage)}%`;
        }

        function checkLevelUp() {
            if (activeTileCount >= ALL_TILES.length) return;
            if (score >= currentLevel * LEVEL_THRESHOLD) {
                currentLevel++;
                activeTileCount++;
                levelEl.innerText = currentLevel;
                playLevelUpSound();
                levelUpToast.style.opacity = '1';
                levelUpToast.style.transform = 'translate(-50%, -150%) rotate(0deg) scale(1.2)';
                setTimeout(() => {
                    levelUpToast.style.opacity = '0';
                    levelUpToast.style.transform = 'translate(-50%, -50%) rotate(-5deg) scale(1)';
                }, 2000);
                timeLeft += 15;
                timeEl.innerText = timeLeft;
                timeEl.classList.add('text-green-400');
                setTimeout(() => timeEl.classList.remove('text-green-400'), 500);
            }
            updateProgressBar();
        }

        function checkFireworks() {
            if (score >= FIREWORKS_THRESHOLD && !hasWonFireworks) {
                hasWonFireworks = true;
                startFireworks();
            }
        }

        function createBoard() {
            for (let y = 0; y < GRID_SIZE; y++) {
                let row = [];
                for (let x = 0; x < GRID_SIZE; x++) {
                    const tileData = getRandomTile();
                    const tile = createTileElement(tileData, x, y);
                    row.push({ tileData, x, y, element: tile });
                    gridEl.appendChild(tile);
                }
                grid.push(row);
            }
        }

        function createTileElement(tileData, x, y) {
            const div = document.createElement('div');
            div.className = 'grid-cell w-full h-full cursor-pointer hover:brightness-110 active:scale-95 flex items-center justify-center p-[2px] relative';
            div.innerHTML = getIconSVG(tileData);
            div.dataset.x = x;
            div.dataset.y = y;
            
            // Click Event
            div.onclick = () => handleTileClick(x, y);
            
            // Touch Events for Swipe
            div.addEventListener('touchstart', handleTouchStart, {passive: false});
            div.addEventListener('touchmove', handleTouchMove, {passive: false});
            div.addEventListener('touchend', handleTouchEnd, {passive: false});
            
            return div;
        }

        // --- Swipe Logic ---
        function handleTouchStart(evt) {
            if (isProcessing) return;
            const firstTouch = evt.touches[0];
            touchStartX = firstTouch.clientX;
            touchStartY = firstTouch.clientY;
            
            const x = parseInt(this.dataset.x);
            const y = parseInt(this.dataset.y);
        }

        function handleTouchMove(evt) {
            // Prevent scrolling
            if (evt.cancelable) evt.preventDefault(); 
        }

        function handleTouchEnd(evt) {
            if (isProcessing || timeLeft <= 0) return;
            
            const changedTouch = evt.changedTouches[0];
            touchEndX = changedTouch.clientX;
            touchEndY = changedTouch.clientY;
            
            handleSwipe(this);
        }

        function handleSwipe(element) {
            const xDiff = touchEndX - touchStartX;
            const yDiff = touchEndY - touchStartY;
            const originX = parseInt(element.dataset.x);
            const originY = parseInt(element.dataset.y);
            
            // Threshold for swipe detection (px)
            if (Math.abs(xDiff) < 30 && Math.abs(yDiff) < 30) {
                return; // Treated as tap/click by onclick handler
            }

            // Determine direction
            let targetX = originX;
            let targetY = originY;

            if (Math.abs(xDiff) > Math.abs(yDiff)) {
                // Horizontal
                if (xDiff > 0) targetX++; else targetX--;
            } else {
                // Vertical
                if (yDiff > 0) targetY++; else targetY--;
            }

            // Boundary Check
            if (targetX < 0 || targetX >= GRID_SIZE || targetY < 0 || targetY >= GRID_SIZE) return;

            // Execute Swap
            const originTile = grid[originY][originX];
            const targetTile = grid[targetY][targetX];
            
            // If origin isn't selected, select it silently for the swap function logic
            selectedTile = originTile; 
            originTile.element.classList.add('selected');
            
            // Then swap with target
            swapTiles(originTile, targetTile);
            deselectTile();
        }

        function handleTileClick(x, y) {
            if (isProcessing || timeLeft <= 0) return;
            const clickedTile = grid[y][x];

            if (clickedTile.tileData.id === 'Mystery') {
                activateMysteryTile(clickedTile);
                return;
            }
            
            if (clickedTile.tileData.id === 'Bomb') {
                activateBombTile(clickedTile);
                return;
            }

            if (selectedTile) {
                if (selectedTile.x === x && selectedTile.y === y) {
                    deselectTile();
                } else if (Math.abs(selectedTile.x - x) + Math.abs(selectedTile.y - y) === 1) {
                    swapTiles(selectedTile, clickedTile);
                    deselectTile();
                } else {
                    deselectTile();
                    selectTile(clickedTile);
                }
            } else {
                selectTile(clickedTile);
            }
        }

        // --- Mystery Tile Logic ---
        function activateMysteryTile(tileObj) {
            isProcessing = true;
            deselectTile();
            playMysterySound();

            const targetIndex = Math.floor(Math.random() * activeTileCount);
            const targetTileData = ALL_TILES[targetIndex];

            let rouletteSteps = 0;
            const rouletteInterval = setInterval(() => {
                const randomIdx = Math.floor(Math.random() * activeTileCount);
                tileObj.element.innerHTML = getIconSVG(ALL_TILES[randomIdx]);
                rouletteSteps++;
                
                if (rouletteSteps > 8) {
                    clearInterval(rouletteInterval);
                    tileObj.element.innerHTML = getIconSVG(targetTileData);
                    tileObj.element.classList.add('selected'); 

                    const shakingTiles = [];
                    for (let y = 0; y < GRID_SIZE; y++) {
                        for (let x = 0; x < GRID_SIZE; x++) {
                            const t = grid[y][x];
                            if (t !== tileObj && t.tileData && t.tileData.id === targetTileData.id) {
                                shakingTiles.push(t);
                            }
                        }
                    }
                    
                    tileObj.element.classList.add('shake-intense');
                    shakingTiles.forEach(t => t.element.classList.add('shake-intense'));

                    setTimeout(() => {
                        tileObj.element.classList.remove('shake-intense');
                        shakingTiles.forEach(t => t.element.classList.remove('shake-intense'));
                        triggerMysteryClear(targetTileData.id, tileObj);
                    }, 2000);
                }
            }, 100);
        }

        // --- Bomb Tile Logic ---
        function activateBombTile(tileObj) {
            isProcessing = true;
            deselectTile();
            playBombSound();
            tileObj.element.classList.add('shake-intense');
            setTimeout(() => {
                triggerBombClear(tileObj);
            }, 800);
        }

        function getFireSVG() {
             return `
                <svg viewBox="0 0 100 100" class="w-full h-full explosion-fire">
                    <circle cx="50" cy="50" r="40" fill="url(#fireGradient)"/>
                    <defs>
                        <radialGradient id="fireGradient">
                            <stop offset="0%" stop-color="#ffff00"/>
                            <stop offset="50%" stop-color="#ff8800"/>
                            <stop offset="100%" stop-color="#ff0000"/>
                        </radialGradient>
                    </defs>
                </svg>
             `;
        }

        async function triggerBombClear(bombTileObj) {
            const rowY = bombTileObj.y;
            const bombX = bombTileObj.x;
            const matches = [];

            for(let x=0; x<GRID_SIZE; x++) {
                matches.push(grid[rowY][x]);
            }

            gameContainer.classList.add('screen-shake-combo');
            setTimeout(() => gameContainer.classList.remove('screen-shake-combo'), 300);

            matches.forEach((cell) => {
                const distance = Math.abs(cell.x - bombX);
                setTimeout(() => {
                    cell.element.innerHTML = getFireSVG();
                }, distance * 50); 
            });

            await new Promise(r => setTimeout(r, 600));

            const points = matches.length * 30;
            score += points;
            scoreEl.innerText = score;
            checkLevelUp();
            checkFireworks();

            matches.forEach(m => {
                m.element.innerHTML = ''; 
                m.element.classList.remove('match-anim', 'shake-anim', 'shake-intense');
                m.tileData = null;
            });

            await applyGravityAndRefill();
            isProcessing = false;
        }

        async function triggerMysteryClear(targetId, mysteryTileObj) {
            mysteryTileObj.element.classList.remove('selected');
            playMassiveClearSound();
            flashOverlay.classList.add('screen-flash');
            setTimeout(() => flashOverlay.classList.remove('screen-flash'), 500);

            const matches = [];
            matches.push(mysteryTileObj);

            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    const tile = grid[y][x];
                    if (tile === mysteryTileObj) continue;
                    if (tile.tileData && tile.tileData.id === targetId) {
                        matches.push(tile);
                    }
                }
            }

            const points = matches.length * 50; 
            score += points;
            scoreEl.innerText = score;
            checkLevelUp();
            checkFireworks();

            matches.forEach(m => {
                m.element.classList.add('match-anim');
            });

            await new Promise(r => setTimeout(r, 400));

             matches.forEach(m => {
                m.element.classList.remove('match-anim');
                m.tileData = null;
            });

            await applyGravityAndRefill();
            isProcessing = false;
        }

        async function applyGravityAndRefill() {
             for (let x = 0; x < GRID_SIZE; x++) {
                let writeIndex = GRID_SIZE - 1;
                for (let y = GRID_SIZE - 1; y >= 0; y--) {
                    if (grid[y][x].tileData !== null) {
                        if (writeIndex !== y) {
                            grid[writeIndex][x].tileData = grid[y][x].tileData;
                            grid[y][x].tileData = null;
                        }
                        writeIndex--;
                    }
                }
                for (let y = writeIndex; y >= 0; y--) {
                    grid[y][x].tileData = getRandomTile();
                }
            }
            renderBoardFromState();
            
            await new Promise(r => setTimeout(r, 200));
            const newMatches = findMatches();
            if (newMatches.length > 0) {
                await processMatches(newMatches, 1);
            }
        }

        function selectTile(tileObj) {
            selectedTile = tileObj;
            tileObj.element.classList.add('selected');
            playTone(400, 'triangle', 0.05); 
        }

        function deselectTile() {
            if (selectedTile) {
                selectedTile.element.classList.remove('selected');
                selectedTile = null;
            }
        }

        async function swapTiles(tile1, tile2) {
            isProcessing = true;
            playSwapSound();

            const el1 = tile1.element;
            const el2 = tile2.element;

            const r1 = el1.getBoundingClientRect();
            const r2 = el2.getBoundingClientRect();
            const distX = r2.left - r1.left;
            const distY = r2.top - r1.top;

            el1.style.transform = `translate(${distX}px, ${distY}px)`;
            el2.style.transform = `translate(${-distX}px, ${-distY}px)`;
            el1.style.transition = 'transform 0.2s ease-out';
            el2.style.transition = 'transform 0.2s ease-out';

            await new Promise(r => setTimeout(r, 200));

            el1.style.transition = '';
            el2.style.transition = '';
            el1.style.transform = '';
            el2.style.transform = '';

            const tempTileData = tile1.tileData;
            tile1.tileData = tile2.tileData;
            tile2.tileData = tempTileData;

            el1.innerHTML = getIconSVG(tile1.tileData);
            el2.innerHTML = getIconSVG(tile2.tileData);

            const matches = findMatches();
            
            if (matches.length > 0) {
                await processMatches(matches, 1);
            } else {
                playInvalidSound();
                el1.classList.add('shake-anim');
                el2.classList.add('shake-anim');
                const temp = tile1.tileData;
                tile1.tileData = tile2.tileData;
                tile2.tileData = temp;
                await new Promise(r => setTimeout(r, 200)); 
                el1.innerHTML = getIconSVG(tile1.tileData);
                el2.innerHTML = getIconSVG(tile2.tileData);
                el1.classList.remove('shake-anim');
                el2.classList.remove('shake-anim');
            }

            isProcessing = false;
        }

        function findMatches() {
            let matches = new Set();
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE - 2; x++) {
                    const t1 = grid[y][x].tileData?.id;
                    const t2 = grid[y][x+1].tileData?.id;
                    const t3 = grid[y][x+2].tileData?.id;
                    if (t1 && t1 !== 'Mystery' && t1 !== 'Bomb' && t1 === t2 && t2 === t3) {
                        matches.add(grid[y][x]);
                        matches.add(grid[y][x+1]);
                        matches.add(grid[y][x+2]);
                    }
                }
            }
            for (let x = 0; x < GRID_SIZE; x++) {
                for (let y = 0; y < GRID_SIZE - 2; y++) {
                    const t1 = grid[y][x].tileData?.id;
                    const t2 = grid[y+1][x].tileData?.id;
                    const t3 = grid[y+2][x].tileData?.id;
                    if (t1 && t1 !== 'Mystery' && t1 !== 'Bomb' && t1 === t2 && t2 === t3) {
                        matches.add(grid[y][x]);
                        matches.add(grid[y+1][x]);
                        matches.add(grid[y+2][x]);
                    }
                }
            }
            return Array.from(matches);
        }

        // --- Visual Combo Effect ---
        function showComboVisual(count) {
            const existing = document.querySelector('.combo-text-anim');
            if(existing) existing.remove();

            gameContainer.classList.remove('screen-shake-combo');
            void gameContainer.offsetWidth; 
            gameContainer.classList.add('screen-shake-combo');

            const comboDiv = document.createElement('div');
            comboDiv.innerText = `COMBO x${count}!`;
            comboDiv.className = 'combo-text-anim';
            gridEl.appendChild(comboDiv);
        }

        async function processMatches(matches, comboCount) {
            isProcessing = true;
            playMatchSound(comboCount);

            if (comboCount > 1) {
                showComboVisual(comboCount);
            }

            matches.forEach(m => {
                m.element.classList.add('match-anim');
            });

            const points = matches.length * 10 * comboCount;
            score += points;
            scoreEl.innerText = score;
            checkLevelUp();
            checkFireworks();

            await new Promise(r => setTimeout(r, 400));

            matches.forEach(m => {
                m.element.classList.remove('match-anim');
                m.tileData = null;
            });

            await applyGravityAndRefill(); 
            isProcessing = false; 
        }

        function renderBoardFromState() {
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    grid[y][x].element.innerHTML = getIconSVG(grid[y][x].tileData);
                }
            }
        }

        function cleanInitialBoard() {
            let matches = findMatches();
            let specialTiles = grid.flat().filter(cell => cell.tileData && (cell.tileData.id === 'Mystery' || cell.tileData.id === 'Bomb'));
            
            while (matches.length > 0 || specialTiles.length > 0) {
                matches.forEach(m => m.tileData = getRandomTile());
                specialTiles.forEach(m => m.tileData = getRandomTile());
                
                renderBoardFromState();
                matches = findMatches();
                specialTiles = grid.flat().filter(cell => cell.tileData && (cell.tileData.id === 'Mystery' || cell.tileData.id === 'Bomb'));
            }
        }

        function endGame() {
            clearInterval(gameInterval);
            isProcessing = true;
            
            updateLocalLeaderboard(score);

            overlayEl.classList.remove('hidden');
            startScreenContent.classList.add('hidden');
            gameOverContent.classList.remove('hidden');
            finalScoreEl.innerText = score;
            
            // Check Reward condition
            if (score > 10000) {
                rewardBtn.classList.remove('hidden');
            } else {
                rewardBtn.classList.add('hidden');
            }
        }
        
        // --- Leaderboard Toggle ---
        leaderboardHeader.addEventListener('click', () => {
            if (window.innerWidth >= 768) return; 
            isLeaderboardOpen = !isLeaderboardOpen;
            if (isLeaderboardOpen) {
                leaderboardSection.style.height = '320px'; 
                leaderboardContent.classList.remove('hidden');
                setTimeout(() => leaderboardContent.classList.remove('opacity-0'), 10);
                chevronIcon.style.transform = 'rotate(180deg)';
            } else {
                leaderboardSection.style.height = '56px'; 
                leaderboardContent.classList.add('opacity-0');
                setTimeout(() => leaderboardContent.classList.add('hidden'), 300);
                chevronIcon.style.transform = 'rotate(0deg)';
            }
        });

        // --- Button Listeners ---
        startBtn.addEventListener('click', () => {
            const val = nameInput.value.trim();
            if (val) playerName = val;
            initAudio();
            initGame();
        });

        restartBtn.addEventListener('click', () => {
            overlayEl.classList.remove('hidden');
            startScreenContent.classList.remove('hidden');
            gameOverContent.classList.add('hidden');
        });
        
        // Share Button (LIFF ShareTargetPicker with Fallback)
        shareBtn.addEventListener('click', async () => {
            const shareText = `üî• ÊàëÂú®Â•ßÂ§öÊØîÊ∂àÊ∂àÊ®ÇÊãø‰∫Ü ${score} ÂàÜÔºÅÂø´‰æÜÊåëÊà∞ÊàëÁöÑÁ¥ÄÈåÑÔºÅ`;
            const shareUrl = window.location.href; // Or specific URL

            // 1. Try LIFF ShareTargetPicker (Best for LINE)
            if (liff.isInClient() && liff.isApiAvailable('shareTargetPicker')) {
                try {
                    const result = await liff.shareTargetPicker([
                        {
                            type: "text",
                            text: shareText
                        }
                    ]);
                    if (result) return; // Success
                } catch (err) {
                    console.error("LIFF Share Error", err);
                }
            }

            // 2. Fallback to Web Share API (Mobile Browsers / Desktop Safari)
            if (navigator.share) {
                try {
                    await navigator.share({
                        title: 'Â•ßÂ§öÊØîÊ∂àÊ∂àÊ®Ç',
                        text: shareText,
                        url: shareUrl
                    });
                    return;
                } catch (err) {
                    console.error("Web Share Error", err);
                }
            }

            // 3. Last Fallback: Copy to Clipboard
            try {
                await navigator.clipboard.writeText(`${shareText} ${shareUrl}`);
                alert("Â∑≤Ë§áË£ΩÂàÜ‰∫´ÈÄ£ÁµêÔºÅ");
            } catch (err) {
                alert("ÁÑ°Ê≥ïÂàÜ‰∫´ÔºåË´ãÊâãÂãïÊà™ÂúñÂàÜ‰∫´ÔºÅ");
            }
        });

        // Reward Button (Send Message via LIFF for BotBonnie)
        rewardBtn.addEventListener('click', async () => {
            if (!liff.isLoggedIn()) {
                alert("Ë´ãÂÖàÁôªÂÖ• LINE ÊâçËÉΩÈ†òÂèñÔºÅ");
                liff.login();
                return;
            }
            try {
                await liff.sendMessages([
                    {
                        type: 'text',
                        text: '#winÊ∂àÊ∂àÊ®Ç'
                    }
                ]);
                alert("ÁçéÂãµÊåá‰ª§Â∑≤ÁôºÈÄÅÔºÅË´ãÊü•ÁúãËÅäÂ§©ÂÆ§„ÄÇ");
                liff.closeWindow();
            } catch (err) {
                console.error("Send Message Error", err);
                alert("ÁÑ°Ê≥ïÁôºÈÄÅË®äÊÅØÔºåË´ãÊâãÂãïËº∏ÂÖ• #winÊ∂àÊ∂àÊ®Ç");
            }
        });

        // Initialize
        initLiff();
        loadLocalLeaderboard();

    </script>
</body>
</html>
