<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>奧多比跳跳樂</title>
    <meta name="apple-mobile-web-app-capable" content="yes">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&family=Noto+Sans+TC:wght@400;700;900&display=swap');

        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Noto Sans TC', 'Inter', sans-serif;
            background: radial-gradient(circle at center, #2b2b2b 0%, #0d0d0d 100%);
            color: #fff;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none;
            -webkit-tap-highlight-color: transparent;
        }

        #ui-layer {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
        }

        /* HUD */
        #hud {
            position: absolute;
            top: 40px; left: 30px;
            z-index: 10;
            display: flex;
            flex-direction: column;
            align-items: flex-start;
        }

        #score-container {
            display: flex;
            align-items: baseline;
            text-shadow: 0 2px 10px rgba(0,0,0,0.5);
        }

        #score {
            font-size: 72px;
            font-weight: 900;
            letter-spacing: -2px;
            line-height: 1;
            margin-right: 8px;
        }

        #score-unit {
            font-size: 18px;
            font-weight: 700;
            color: rgba(255,255,255,0.7);
            letter-spacing: 1px;
        }

        #combo-badge {
            background: linear-gradient(135deg, #FFD700, #FFA500);
            color: #000;
            padding: 6px 16px;
            border-radius: 20px;
            font-weight: 900;
            font-size: 16px;
            display: inline-block;
            transform: translateY(-10px) rotate(-3deg);
            opacity: 0;
            box-shadow: 0 4px 15px rgba(255, 165, 0, 0.5);
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            margin-top: 10px;
            border: 2px solid #fff;
        }
        #combo-badge.visible { opacity: 1; transform: translateY(0) rotate(-3deg) scale(1.1); }

        /* Power Bar */
        #power-bar-container {
            position: absolute;
            top: 50%; left: 50%;
            width: 100px; height: 12px;
            background: rgba(0, 0, 0, 0.6);
            border-radius: 6px;
            transform: translate(-50%, -50%);
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
            overflow: hidden;
            z-index: 40;
            border: 2px solid rgba(255,255,255,0.3);
            backdrop-filter: blur(4px);
        }

        #power-bar {
            height: 100%; width: 0%;
            background: linear-gradient(90deg, #00f2fe 0%, #4facfe 100%);
            box-shadow: 0 0 15px rgba(0, 242, 254, 0.8);
            transition: background 0.2s;
        }
        
        #power-bar.overload {
            background: linear-gradient(90deg, #ff0844 0%, #ffb199 100%);
            box-shadow: 0 0 20px rgba(255, 8, 68, 0.8);
        }

        /* Warning Text */
        #warning-text {
            position: absolute; 
            top: 20%; 
            left: 0; width: 100%;
            text-align: center;
            color: #ff3333; 
            font-weight: 900; 
            font-size: 28px; 
            letter-spacing: 2px;
            text-shadow: 0 0 20px rgba(255, 0, 0, 0.8);
            opacity: 0; 
            pointer-events: none;
            z-index: 45;
        }
        #warning-text.visible { animation: blink 0.2s infinite alternate; opacity: 1; }
        @keyframes blink { from { opacity: 0.5; transform: scale(0.95); } to { opacity: 1; transform: scale(1.05); } }

        /* Card */
        #card {
            position: absolute;
            top: 40px; right: 20px;
            background: rgba(20, 20, 20, 0.9);
            backdrop-filter: blur(25px);
            -webkit-backdrop-filter: blur(25px);
            padding: 16px;
            border-radius: 12px;
            border: 1px solid rgba(255,255,255,0.15);
            border-left: 4px solid #fff;
            width: 240px;
            transform: translateX(20px);
            opacity: 0;
            transition: all 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
            pointer-events: none;
            box-shadow: 0 10px 30px rgba(0,0,0,0.4);
            z-index: 30;
        }
        #card.visible { opacity: 1; transform: translateX(0); }
        
        .card-header { display: flex; align-items: center; margin-bottom: 8px; border-bottom: 1px solid rgba(255,255,255,0.1); padding-bottom: 8px; }
        .card-icon { width: 32px; height: 32px; margin-right: 10px; background-size: cover; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.3); flex-shrink: 0; }
        .card-title { font-weight: 700; font-size: 16px; letter-spacing: 0.5px; }
        .card-desc { font-size: 12px; color: #ddd; line-height: 1.5; text-align: justify; }

        /* Floating Score */
        .floating-score {
            position: absolute;
            font-weight: 900;
            font-size: 32px;
            color: #fff;
            text-shadow: 0 4px 15px rgba(0,0,0,0.6);
            pointer-events: none;
            z-index: 30;
            white-space: nowrap;
        }
        .floating-score.perfect { color: #FFD700; font-size: 48px; text-shadow: 0 0 20px rgba(255, 215, 0, 0.6); }

        /* Controls */
        #controls {
            position: absolute;
            bottom: 30px; right: 30px;
            display: flex; gap: 15px;
            pointer-events: auto;
            z-index: 50;
        }
        .circle-btn {
            width: 48px; height: 48px;
            border-radius: 50%;
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            display: flex; justify-content: center; align-items: center;
            cursor: pointer;
            backdrop-filter: blur(10px);
            transition: all 0.2s;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
        }
        .circle-btn:hover { background: rgba(255,255,255,0.2); transform: scale(1.05); }
        .circle-btn:active { transform: scale(0.95); }
        .circle-btn svg { fill: white; width: 20px; height: 20px; }

        /* In-game Restart Button */
        #ingame-restart {
            position: absolute;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.25);
            color: rgba(255,255,255,0.9);
            padding: 12px 28px;
            border-radius: 30px;
            font-size: 15px;
            font-weight: 600;
            cursor: pointer;
            pointer-events: auto;
            backdrop-filter: blur(8px);
            transition: all 0.2s;
            z-index: 50;
            letter-spacing: 1px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            display: flex;
            align-items: center;
            gap: 8px;
        }
        #ingame-restart:hover { background: rgba(255,255,255,0.2); color: #fff; transform: translateX(-50%) scale(1.05); }
        #ingame-restart:active { transform: translateX(-50%) scale(0.95); }
        
        /* Hide ingame restart during menus */
        body.menu-active #ingame-restart { display: none; }

        /* Overlay */
        .overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85);
            backdrop-filter: blur(20px);
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            opacity: 0; pointer-events: none;
            transition: opacity 0.5s; z-index: 60;
        }
        .overlay.active { opacity: 1; pointer-events: auto; }
        
        .main-btn {
            margin-top: 30px; padding: 16px 50px;
            background: #fff; color: #000;
            border: none; font-weight: 900; font-size: 18px; letter-spacing: 2px;
            cursor: pointer; text-transform: uppercase; border-radius: 4px;
            transition: transform 0.2s, box-shadow 0.2s;
            font-family: 'Noto Sans TC', sans-serif;
            box-shadow: 0 10px 40px rgba(255,255,255,0.15);
            min-width: 180px;
            pointer-events: auto;
        }
        .main-btn:hover { transform: translateY(-4px); box-shadow: 0 15px 50px rgba(255,255,255,0.3); }
        
        .main-btn.secondary {
            background: transparent; color: #fff; border: 2px solid rgba(255,255,255,0.2);
        }
        .main-btn.secondary:hover { background: rgba(255,255,255,0.1); border-color: #fff; }

        .main-btn.share {
            background: #0095f6; color: #fff;
        }
        .main-btn.share:hover {
            background: #0085dd; box-shadow: 0 10px 40px rgba(0, 149, 246, 0.4);
        }

        .btn-group { display: flex; gap: 15px; flex-wrap: wrap; justify-content: center; width: 90%; }

        /* Hint */
        #hint {
            position: absolute; bottom: 100px; width: 100%; text-align: center;
            font-size: 12px; color: rgba(255,255,255,0.4); letter-spacing: 2px;
            pointer-events: none; font-weight: 500;
            text-transform: uppercase;
            text-shadow: 0 2px 4px rgba(0,0,0,0.8);
        }
        
        @media (max-width: 600px) {
            #hud { top: 20px; left: 20px; }
            #score { font-size: 54px; }
            #card { top: 70px; right: 10px; width: 200px; padding: 12px; }
            .card-desc { font-size: 11px; line-height: 1.4; }
            #controls { bottom: 20px; right: 20px; }
            .main-btn { padding: 14px 30px; font-size: 16px; min-width: 140px; }
            #ingame-restart { bottom: 90px; } 
            #hint { bottom: 50px; font-size: 10px; }
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body class="menu-active">

    <div id="ui-layer">
        <div id="hud">
            <div id="score-container">
                <div id="score">0</div>
                <div id="score-unit">層</div>
            </div>
            <div id="combo-badge">連擊 x2</div>
        </div>

        <div id="power-bar-container">
            <div id="power-bar"></div>
        </div>
        
        <div id="warning-text">再不放手！就要破啦！</div>

        <!-- 軟體說明卡片 -->
        <div id="card">
            <div class="card-header">
                <div id="card-icon" class="card-icon"></div>
                <span id="card-title" class="card-title">軟體名稱</span>
            </div>
            <div id="card-desc" class="card-desc">軟體說明...</div>
        </div>

        <div id="hint">按住蓄力跳躍 • 拖曳旋轉視角</div>

        <div id="controls">
            <div class="circle-btn" id="btn-reset" title="重置視角">
                <svg viewBox="0 0 24 24"><path d="M12 5V1L7 6l5 5V7c3.31 0 6 2.69 6 6s-2.69 6-6 6-6-2.69-6-6H4c0 4.42 3.58 8 8 8s8-3.58 8-8-3.58-8-8-8z"/></svg>
            </div>
        </div>
        
        <!-- 遊戲中重置按鈕 -->
        <button id="ingame-restart">↺ 重新開始</button>
    </div>

    <!-- Start Screen -->
    <div id="start-screen" class="overlay active">
        <h1 style="font-size: 54px; letter-spacing: 2px; font-weight: 900; text-shadow: 0 10px 30px rgba(0,0,0,0.5); text-align: center;">奧多比<br>跳跳樂</h1>
        <button class="main-btn" id="start-btn">開始挑戰</button>
    </div>

    <!-- Game Over -->
    <div id="game-over" class="overlay">
        <h1 style="font-size: 40px; letter-spacing: 2px; font-weight: 900;">挑戰失敗</h1>
        <p style="color: #bbb; margin-top: 10px; font-size: 20px; font-weight: 700;">最終成績: <span id="final-score" style="color:#fff;">0</span> 層</p>
        <div class="btn-group">
            <button class="main-btn secondary" id="restart-btn">重新開始</button>
            <button class="main-btn share" id="revive-btn">分享接關</button>
        </div>
    </div>

    <script>
        // --- 1. Utility Functions ---
        function distanceXZ(v1, v2) {
            return Math.sqrt(Math.pow(v1.x - v2.x, 2) + Math.pow(v1.z - v2.z, 2));
        }

        // --- 2. Configuration & Assets ---
        const ASSETS = [
            { id: 'Ps', color: '#31a8ff', url: 'https://adbeweblink.github.io/myproject/images/ps.png', name: 'Photoshop', desc: '全球創意影像處理的黃金標準。無論是照片編修、數位繪畫、還是平面設計，Photoshop 提供了無與倫比的圖層控制。' },
            { id: 'Ai', color: '#ff9a00', url: 'https://adbeweblink.github.io/myproject/images/Ai.png', name: 'Illustrator', desc: '業界領先的向量圖形設計軟體。不同於像素圖像，Illustrator 創建的圖形可以無限縮放而不失真，非常適合設計標誌與插圖。' },
            { id: 'Pr', color: '#00005b', url: 'https://adbeweblink.github.io/myproject/images/Pr.png', name: 'Premiere Pro', desc: '專業級影片剪輯與製作軟體，深受好萊塢電影製片人、電視廣播公司及 YouTuber 的信賴。它提供了強大的非線性編輯時間軸、色彩校正 (Lumetri Color)、音效修復與多機剪輯功能。' },
            { id: 'Ae', color: '#00005b', url: 'https://adbeweblink.github.io/myproject/images/Ae.png', name: 'After Effects', desc: '電影視覺特效與動態圖形設計的標準工具。這款軟體能讓靜態影像「動」起來，創造震撼的視覺體驗。' },
            { id: 'Id', color: '#ff3366', url: 'https://adbeweblink.github.io/myproject/images/Id.png', name: 'InDesign', desc: '專業的版面設計與桌面排版軟體，專為印刷與數位出版打造。無論是書籍、雜誌、電子書、互動式 PDF 還是海報，InDesign 都能提供精確到像素的排版控制。' },
            { id: 'Lr', color: '#31a8ff', url: 'https://adbeweblink.github.io/myproject/images/lr.png', name: 'Lightroom', desc: '專為攝影愛好者與專業人士設計的雲端相片服務。它集相片管理、編輯與分享於一身。非破壞性的編輯流程讓您可以隨時還原原始照片。' },
            { id: 'Dc', color: '#ed1c24', url: 'https://adbeweblink.github.io/myproject/images/Dc.png', name: 'Acrobat Pro', desc: '全球最完整的 PDF 文件解決方案。Acrobat 不僅僅是閱讀器，它讓您能夠在任何裝置上建立、編輯、轉檔、簽署與追蹤 PDF 文件。' },
            { id: 'Ff', color: '#e0e0e0', url: 'https://adbeweblink.github.io/myproject/images/Firefly.png', name: 'Firefly', desc: 'Adobe 的創意生成式 AI 引擎。讓創作者僅需透過簡單的文字提示，即可生成高品質的圖像。' }
        ];
        const CC_ICON_URL = 'https://adbeweblink.github.io/myproject/images/CC.png';

        const CONFIG = {
            boxSize: 10,
            playerSize: 5,
            gravity: 0.32,       
            maxChargeTime: 2000,
            overloadLimit: 5000,
            rotateSpeed: 0.005,
            elevateSpeed: 0.005,
            zoomSpeed: 0.05,
            minZoom: 0.5,
            maxZoom: 2.0
        };

        let scene, camera, renderer;
        let player, shadowPlane;
        let platforms = [];
        let particles = [];
        let chargeParticles = []; 
        let score = 0;
        let combo = 0;
        let state = 'start'; 
        
        let camRadius = 45;
        let camTheta = Math.PI / 4;
        let camPhi = Math.PI / 3;
        let camZoom = 1.0;
        let userZoom = 1.0;
        
        let targetTheta = Math.PI / 4;
        let targetPhi = Math.PI / 3;
        let targetZoom = 1.0;
        let camFocus = new THREE.Vector3(0, 0, 0);

        let isDragging = false;
        let startX = 0, startY = 0;
        let isMoved = false;
        let chargeStartTime = 0;
        let chargeBasePos = new THREE.Vector3(); 
        let lastSafePos = new THREE.Vector3(); 

        let velocity = new THREE.Vector3();
        let jumpStartPos = new THREE.Vector3();
        let jumpDuration = 0;

        const textures = {};
        const textureLoader = new THREE.TextureLoader();
        textureLoader.crossOrigin = 'Anonymous';

        const ui = {
            score: document.getElementById('score'),
            comboBadge: document.getElementById('combo-badge'),
            powerBar: document.getElementById('power-bar'),
            powerCont: document.getElementById('power-bar-container'),
            card: document.getElementById('card'),
            cardTitle: document.getElementById('card-title'),
            cardDesc: document.getElementById('card-desc'),
            cardIcon: document.getElementById('card-icon'),
            start: document.getElementById('start-screen'),
            end: document.getElementById('game-over'),
            finalScore: document.getElementById('final-score'),
            layer: document.getElementById('ui-layer'),
            warning: document.getElementById('warning-text'),
            body: document.body
        };

        function init() {
            preloadTextures();

            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x1a1a1a, 20, 150);

            const aspect = window.innerWidth / window.innerHeight;
            const d = 40;
            camera = new THREE.OrthographicCamera(-d * aspect, d * aspect, d, -d, 1, 1000);
            updateCamera(true);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);

            const ambient = new THREE.AmbientLight(0xffffff, 0.4);
            scene.add(ambient);

            const dirLight = new THREE.DirectionalLight(0xffffff, 0.9);
            dirLight.position.set(40, 80, 60);
            dirLight.castShadow = true;
            // 擴大陰影相機範圍以防破圖
            dirLight.shadow.mapSize.width = 4096;
            dirLight.shadow.mapSize.height = 4096;
            dirLight.shadow.camera.left = -200;
            dirLight.shadow.camera.right = 200;
            dirLight.shadow.camera.top = 200;
            dirLight.shadow.camera.bottom = -200;
            dirLight.shadow.bias = -0.0005;
            scene.add(dirLight);

            const fillLight = new THREE.DirectionalLight(0xaaccff, 0.5);
            fillLight.position.set(-50, 40, -50);
            scene.add(fillLight);

            // 使用 ShadowMaterial 製作透明地面，只顯示陰影
            const planeGeo = new THREE.PlaneGeometry(1000, 1000); // 加大地面
            const planeMat = new THREE.ShadowMaterial({ opacity: 0.3, color: 0x000000 });
            const ground = new THREE.Mesh(planeGeo, planeMat);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = -6; // 下移
            ground.receiveShadow = true;
            scene.add(ground);

            window.addEventListener('resize', onResize);
            
            const cvs = renderer.domElement;
            cvs.addEventListener('mousedown', onDown);
            cvs.addEventListener('touchstart', onDown, {passive: false});
            window.addEventListener('mousemove', onMove);
            window.addEventListener('touchmove', onMove, {passive: false});
            window.addEventListener('mouseup', onUp);
            window.addEventListener('touchend', onUp);
            window.addEventListener('wheel', onWheel, {passive: false});

            window.addEventListener('keydown', e => {
                if (e.code === 'Space') {
                    if (e.repeat) return;
                    if (state === 'idle') {
                        e.preventDefault();
                        startCharge();
                    }
                }
            });
            window.addEventListener('keyup', e => {
                if (e.code === 'Space' && state === 'charging') {
                    e.preventDefault();
                    endCharge();
                }
            });

            document.getElementById('start-btn').onclick = startGame;
            document.getElementById('restart-btn').onclick = resetGame;
            document.getElementById('btn-reset').onclick = resetView;
            document.getElementById('revive-btn').onclick = reviveGame;
            document.getElementById('ingame-restart').onclick = resetGame;

            animate();
        }

        function preloadTextures() {
            ASSETS.forEach(a => {
                const t = textureLoader.load(a.url);
                t.center.set(0.5, 0.5);
                t.repeat.set(0.78, 0.78);
                t.anisotropy = 16;
                textures[a.id] = t;
            });
            const pt = textureLoader.load(CC_ICON_URL);
            pt.center.set(0.5, 0.5);
            pt.repeat.set(0.78, 0.78);
            pt.anisotropy = 16;
            textures['CC'] = pt;
        }

        function startGame() {
            ui.start.classList.remove('active');
            ui.body.classList.remove('menu-active');
            resetGame();
        }

        function resetGame() {
            platforms.forEach(p => scene.remove(p));
            platforms = [];
            if (player) scene.remove(player);
            particles.forEach(p => scene.remove(p.mesh));
            particles = [];
            chargeParticles.forEach(p => scene.remove(p.mesh));
            chargeParticles = [];

            score = 0;
            combo = 0;
            updateScoreUI();
            
            targetTheta = Math.PI / 4;
            targetPhi = Math.PI / 3;
            userZoom = 1.0;
            targetZoom = 1.0;
            camFocus.set(0, 0, 0);

            createPlatform(0, 0);
            createPlatform(-18, 0);

            createPlayer();
            lastSafePos.copy(player.position);

            state = 'idle';
            ui.end.classList.remove('active');
            ui.body.classList.remove('menu-active');
            ui.card.classList.remove('visible');
            ui.warning.classList.remove('visible');
            updateCamera(true);
        }

        function reviveGame() {
            ui.end.classList.remove('active');
            ui.body.classList.remove('menu-active');
            ui.card.classList.remove('visible');
            particles.forEach(p => scene.remove(p.mesh));
            particles = [];
            player.visible = true;
            player.scale.set(1, 1, 1);
            player.rotation.set(0, 0, 0);
            player.position.copy(lastSafePos); 
            player.material.color.setHex(0xffffff);
            velocity.set(0,0,0);
            camFocus.copy(lastSafePos);
            state = 'idle';
            updateCamera(false);
        }

        function createPlatform(x, z) {
            const size = CONFIG.boxSize;
            const geo = new THREE.BoxGeometry(size, size, size);
            const asset = ASSETS[Math.floor(Math.random() * ASSETS.length)];
            const tex = textures[asset.id];
            const mat = new THREE.MeshPhongMaterial({ map: tex, color: 0xffffff, specular: 0x333333, shininess: 30 });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.set(x, 0, z); 
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            mesh.userData = { asset: asset };
            scene.add(mesh);
            platforms.push(mesh);
            if (platforms.length > 8) {
                const old = platforms.shift();
                scene.remove(old);
            }
        }

        function generateNext() {
            const last = platforms[platforms.length - 1];
            const dir = Math.random() > 0.5 ? 0 : 1; 
            const minGap = 5, maxGap = 22;
            const gap = minGap + Math.random() * (maxGap - minGap);
            const dist = CONFIG.boxSize + gap;
            let nx = last.position.x, nz = last.position.z;
            if (dir === 0) nx -= dist; else nz -= dist;
            createPlatform(nx, nz);
        }

        function createPlayer() {
            const size = CONFIG.playerSize;
            const geo = new THREE.BoxGeometry(size, size, size);
            const mat = new THREE.MeshPhongMaterial({ map: textures['CC'], color: 0xffffff, specular: 0x555555, shininess: 50 });
            player = new THREE.Mesh(geo, mat);
            player.position.set(platforms[0].position.x, 7.5, platforms[0].position.z);
            player.castShadow = true;
            player.receiveShadow = true;
            scene.add(player);
        }

        function onDown(e) {
            if (e.target.closest('button') || e.target.closest('.circle-btn')) return;
            if (e.type === 'touchstart') e.preventDefault();
            if (state !== 'idle') return;

            isDragging = true;
            isMoved = false;
            startX = e.clientX || e.touches[0].clientX;
            startY = e.clientY || e.touches[0].clientY;
            startCharge();
        }

        function onMove(e) {
            if (!isDragging) return;
            const x = e.clientX || e.touches[0]?.clientX;
            const y = e.clientY || e.touches[0]?.clientY;
            if (x === undefined) return;

            const dx = x - startX;
            const dy = y - startY;
            startX = x;
            startY = y;

            if (Math.abs(dx) > 10 || Math.abs(dy) > 10) {
                isMoved = true;
                if (state === 'charging') cancelCharge();
                targetTheta += dx * CONFIG.rotateSpeed;
                targetPhi -= dy * CONFIG.elevateSpeed;
                targetPhi = Math.max(0.1, Math.min(Math.PI / 2 - 0.1, targetPhi));
            }
        }

        function onUp(e) {
            isDragging = false;
            if (state === 'charging') {
                if (!isMoved) endCharge();
                else cancelCharge();
            }
        }

        function onWheel(e) {
            e.preventDefault();
            if (state === 'start') return;
            const delta = e.deltaY > 0 ? -1 : 1;
            userZoom += delta * CONFIG.zoomSpeed;
            userZoom = Math.max(CONFIG.minZoom, Math.min(CONFIG.maxZoom, userZoom));
            if (state !== 'charging') targetZoom = userZoom;
        }

        function resetView() {
            targetTheta = Math.PI / 4;
            targetPhi = Math.PI / 3;
            userZoom = 1.0;
            targetZoom = 1.0;
        }

        function startCharge() {
            state = 'charging';
            chargeStartTime = performance.now();
            chargeBasePos.copy(player.position); 
            ui.powerCont.style.opacity = 1;
            ui.powerBar.style.width = '0%';
            ui.powerBar.className = ''; 
            ui.card.classList.remove('visible');
            ui.warning.classList.remove('visible');
        }

        function cancelCharge() {
            state = 'idle';
            ui.powerCont.style.opacity = 0;
            new TWEEN.Tween(player.scale).to({x:1, y:1, z:1}, 200).easing(TWEEN.Easing.Elastic.Out).start();
            player.material.color.setHex(0xffffff);
            player.position.copy(chargeBasePos);
            ui.warning.classList.remove('visible');
            targetZoom = userZoom;
            clearChargeParticles();
        }

        function endCharge() {
            const dt = performance.now() - chargeStartTime;
            if (dt > CONFIG.maxChargeTime + CONFIG.overloadLimit) return;
            const actualDt = Math.min(dt, CONFIG.maxChargeTime);
            ui.powerCont.style.opacity = 0;
            ui.warning.classList.remove('visible');
            player.material.color.setHex(0xffffff); 
            player.position.copy(chargeBasePos); 
            targetZoom = userZoom; 
            clearChargeParticles();
            jump(actualDt);
        }

        function jump(duration) {
            state = 'jumping';
            player.scale.set(0.8, 1.3, 0.8);
            new TWEEN.Tween(player.scale).to({x:1, y:1, z:1}, 300).start();

            const fromP = platforms[platforms.length - 2];
            const toP = platforms[platforms.length - 1];
            const dir = new THREE.Vector3().subVectors(toP.position, fromP.position).normalize();
            const ratio = duration / CONFIG.maxChargeTime;
            const jumpDist = 5 + ratio * 30;
            const vh = Math.sqrt(jumpDist * CONFIG.gravity / 1.2); 
            const vv = vh * 0.65; 

            velocity.set(dir.x * vh, vv, dir.z * vh);
            const estimatedAirTime = (2 * vv) / CONFIG.gravity;
            jumpDuration = estimatedAirTime; 
            jumpStartPos.copy(player.position);
        }

        function animate() {
            requestAnimationFrame(animate);
            TWEEN.update();

            camTheta += (targetTheta - camTheta) * 0.1;
            camPhi += (targetPhi - camPhi) * 0.1;
            camZoom += (targetZoom - camZoom) * 0.1;
            updateCamera();
            updatePowerBarPos();

            if (state === 'charging') {
                const dt = performance.now() - chargeStartTime;
                targetZoom = userZoom + 0.3; 
                if (dt <= CONFIG.maxChargeTime) {
                    const p = dt / CONFIG.maxChargeTime;
                    ui.powerBar.style.width = (p * 100) + '%';
                    const sy = 1 - p * 0.4;
                    const sxz = 1 + p * 0.2;
                    player.scale.set(sxz, sy, sxz);
                    const r = 1, gb = 1 - p * 0.5; 
                    player.material.color.setRGB(r, gb, gb);
                    
                    if (p > 0.5) {
                        player.position.x = chargeBasePos.x + (Math.random()-0.5) * 0.1;
                        player.position.z = chargeBasePos.z + (Math.random()-0.5) * 0.1;
                    }
                    spawnChargeParticle(p);
                } else {
                    ui.powerBar.style.width = '100%';
                    ui.powerBar.className = 'overload';
                    ui.warning.innerText = "再不放手！就要破啦！";
                    ui.warning.classList.add('visible');
                    
                    player.position.x = chargeBasePos.x + (Math.random()-0.5) * 0.4;
                    player.position.z = chargeBasePos.z + (Math.random()-0.5) * 0.4;
                    const pulse = Math.sin(dt * 0.01) * 0.5 + 0.5;
                    player.material.color.setRGB(1, pulse * 0.3, pulse * 0.3);
                    spawnChargeParticle(1.2);

                    if (dt > CONFIG.maxChargeTime + CONFIG.overloadLimit) {
                        createShatterEffect(player.position);
                        player.visible = false;
                        ui.warning.innerText = "爆炸啦！";
                        failGame();
                    }
                }
            }

            if (state === 'jumping') {
                player.position.add(velocity);
                velocity.y -= CONFIG.gravity;
                const rotateStep = (Math.PI * 2) / jumpDuration; 
                if (Math.abs(velocity.x) > Math.abs(velocity.z)) {
                    player.rotation.z -= rotateStep * 1.1; 
                } else {
                    player.rotation.x += rotateStep * 1.1;
                }

                if (velocity.y < 0 && player.position.y <= 7.5) {
                    checkLanding();
                }
                
                if (velocity.y < 0 && player.position.y < -5) {
                    createShatterEffect(player.position);
                    player.visible = false;
                    failGame();
                }
            }

            if (state === 'slipping') {
                player.position.y -= 0.8;
                player.rotation.x += 0.1; 
                player.rotation.z += 0.1;
                player.position.x += velocity.x; 
                player.position.z += velocity.z;
                if (player.position.y < -5) { 
                    createShatterEffect(player.position);
                    player.visible = false; 
                    failGame();
                }
            }

            updateParticles(particles);
            updateParticles(chargeParticles);
            renderer.render(scene, camera);
        }

        function updateCamera(instant = false) {
            if (player) {
                camFocus.x += (player.position.x - camFocus.x) * (instant ? 1 : 0.08);
                camFocus.z += (player.position.z - camFocus.z) * (instant ? 1 : 0.08);
            }
            const r = camRadius;
            const y = r * Math.cos(camPhi);
            const h = r * Math.sin(camPhi); 
            const x = h * Math.sin(camTheta);
            const z = h * Math.cos(camTheta);
            camera.position.set(camFocus.x + x, camFocus.y + y, camFocus.z + z);
            camera.lookAt(camFocus);
            camera.zoom = camZoom;
            camera.updateProjectionMatrix();
        }

        function updatePowerBarPos() {
            if (!player) return;
            const v = player.position.clone();
            v.y += 8;
            v.project(camera);
            const x = (v.x * .5 + .5) * window.innerWidth;
            const y = (v.y * -.5 + .5) * window.innerHeight;
            ui.powerCont.style.left = x + 'px';
            ui.powerCont.style.top = (y + 15) + 'px';
        }

        function checkLanding() {
            const target = platforms[platforms.length - 1];
            const prev = platforms[platforms.length - 2];
            if (!target || !prev) return;
            const dTarget = distanceXZ(player.position, target.position);
            const dPrev = distanceXZ(player.position, prev.position);
            let hit = null, d = 0;
            const strictLimit = 5.0; 
            
            if (dTarget < 8.0) { hit = target; d = dTarget; } 
            else if (dPrev < 8.0) { hit = prev; d = dPrev; }

            if (hit) {
                if (d < strictLimit) {
                    const landY = 7.5;
                    player.position.y = landY;
                    player.scale.set(1.3, 0.7, 1.3);
                    new TWEEN.Tween(player.scale).to({x:1, y:1, z:1}, 400).easing(TWEEN.Easing.Elastic.Out).start();
                    shakeScreen(3);
                    if (d < 2.0) { 
                        player.position.x = hit.position.x;
                        player.position.z = hit.position.z;
                        success(hit, 2);
                    } else { 
                        success(hit, 1);
                    }
                } else {
                    state = 'slipping';
                    shakeScreen(5);
                    const dir = new THREE.Vector3().subVectors(player.position, hit.position).normalize();
                    velocity.set(dir.x * 0.3, -0.5, dir.z * 0.3);
                }
            }
        }

        function success(platform, points) {
            state = 'idle';
            velocity.set(0,0,0);
            player.rotation.set(0,0,0);
            player.material.color.setHex(0xffffff);
            lastSafePos.copy(player.position);

            if (platform === platforms[platforms.length - 1]) {
                if (points === 2) combo++; else combo = 0;
                const bonus = combo > 1 ? combo : 1;
                score += points * bonus;
                generateNext();
                showCard(platform.userData.asset);
                showFloatingScore(platform.position, points, combo);
            } else {
                combo = 0;
            }
            updateScoreUI();
        }

        function createShatterEffect(pos) {
            const count = 25; 
            const geo = new THREE.BoxGeometry(1.5, 1.5, 1.5);
            for(let i=0; i<count; i++) {
                const mat = new THREE.MeshPhongMaterial({ color: 0xffffff });
                const mesh = new THREE.Mesh(geo, mat);
                mesh.position.copy(pos);
                mesh.position.y = -5; 
                mesh.position.x += (Math.random()-0.5)*4;
                mesh.position.z += (Math.random()-0.5)*4;
                scene.add(mesh);
                particles.push({
                    mesh: mesh,
                    vel: new THREE.Vector3((Math.random()-0.5)*3, Math.random()*4, (Math.random()-0.5)*3),
                    life: 1.0,
                    type: 'shatter'
                });
            }
            shakeScreen(20);
        }

        function spawnChargeParticle(intensity) {
            const count = Math.floor(intensity * 2) + 1;
            for(let i=0; i<count; i++) {
                const geo = new THREE.BoxGeometry(0.3, 0.3, 0.3);
                const color = new THREE.Color();
                if (intensity < 0.5) color.setHSL(0.6, 1, 0.7); 
                else if (intensity < 1.0) color.setHSL(0.1, 1, 0.6); 
                else color.setHSL(0, 1, 0.5); 
                const mat = new THREE.MeshBasicMaterial({ color: color, transparent: true, opacity: 0.8 });
                const mesh = new THREE.Mesh(geo, mat);
                const radius = 6;
                const angle = Math.random() * Math.PI * 2;
                const h = (Math.random() - 0.5) * 6;
                mesh.position.set(
                    player.position.x + Math.cos(angle) * radius,
                    player.position.y + h,
                    player.position.z + Math.sin(angle) * radius
                );
                scene.add(mesh);
                const target = player.position.clone();
                const dir = new THREE.Vector3().subVectors(target, mesh.position).normalize();
                const speed = 0.5 + intensity * 0.5;
                chargeParticles.push({
                    mesh: mesh,
                    vel: dir.multiplyScalar(speed),
                    life: 1.0,
                    type: 'charge'
                });
            }
        }
        
        function clearChargeParticles() {
            chargeParticles.forEach(p => scene.remove(p.mesh));
            chargeParticles = [];
        }

        function updateParticles(list) {
            for(let i = list.length - 1; i >= 0; i--) {
                const p = list[i];
                p.mesh.position.add(p.vel);
                if (p.type === 'shatter') {
                    p.vel.y -= 0.2; 
                    p.mesh.rotation.x += 0.2;
                    p.mesh.rotation.y += 0.2;
                    if (p.mesh.position.y < -5) {
                        p.mesh.position.y = -5;
                        p.vel.y *= -0.5;
                        p.vel.x *= 0.8; 
                        p.vel.z *= 0.8;
                    }
                } else if (p.type === 'charge') {
                    p.life -= 0.05;
                    if (p.mesh.position.distanceTo(player.position) < 1) p.life = 0;
                }
                p.mesh.scale.setScalar(p.life);
                if (p.life <= 0 && p.type !== 'shatter') {
                    scene.remove(p.mesh);
                    list.splice(i, 1);
                }
            }
        }

        function showFloatingScore(pos, points, currentCombo) {
            const el = document.createElement('div');
            el.className = 'floating-score';
            if (points === 2) el.classList.add('perfect');
            let text = `+${points}`;
            if (points === 2) text += " 完美！";
            if (currentCombo > 1) text += ` (連擊 x${currentCombo})`;
            el.innerText = text;
            ui.layer.appendChild(el);
            const v = pos.clone(); v.y += 10;
            const updatePos = () => {
                const p = v.clone().project(camera);
                const x = (p.x * .5 + .5) * window.innerWidth;
                const y = (p.y * -.5 + .5) * window.innerHeight;
                el.style.left = x + 'px';
                el.style.top = y + 'px';
            };
            updatePos();
            setTimeout(() => el.remove(), 1000);
        }

        function shakeScreen(intensity = 5) {
            const body = document.body;
            let count = 0;
            const interval = setInterval(() => {
                const dx = (Math.random() - 0.5) * intensity;
                const dy = (Math.random() - 0.5) * intensity;
                body.style.transform = `translate(${dx}px, ${dy}px)`;
                count++;
                if (count > 10) {
                    clearInterval(interval);
                    body.style.transform = 'none';
                }
            }, 16);
        }

        function failGame() {
            if (state === 'ended') return;
            state = 'ended';
            ui.body.classList.add('menu-active');
            
            const overlay = document.createElement('div');
            overlay.style.position = 'absolute';
            overlay.style.top = 0; overlay.style.left = 0;
            overlay.style.width = '100%'; overlay.style.height = '100%';
            overlay.style.backgroundColor = 'rgba(255,0,0,0.3)';
            overlay.style.pointerEvents = 'none';
            document.body.appendChild(overlay);
            setTimeout(() => overlay.remove(), 200);

            ui.finalScore.innerText = score;
            setTimeout(() => ui.end.classList.add('active'), 500); 
            ui.card.classList.remove('visible');
            ui.warning.classList.remove('visible');
            ui.powerCont.style.opacity = 0;
            clearChargeParticles();
        }

        function showCard(asset) {
            ui.cardTitle.innerText = asset.name;
            ui.cardDesc.innerText = asset.desc;
            ui.cardIcon.style.backgroundImage = `url(${asset.url})`;
            ui.card.style.borderLeftColor = asset.color;
            ui.card.classList.remove('visible');
            void ui.card.offsetWidth; 
            ui.card.classList.add('visible');
        }

        function updateScoreUI() {
            ui.score.innerText = score;
            if (combo > 1) {
                ui.comboBadge.innerText = '連擊 x' + combo;
                ui.comboBadge.classList.add('visible');
            } else {
                ui.comboBadge.classList.remove('visible');
            }
        }

        function onResize() {
            const aspect = window.innerWidth / window.innerHeight;
            const d = 40;
            camera.left = -d * aspect;
            camera.right = d * aspect;
            camera.top = d;
            camera.bottom = -d;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // TWEEN
        const TWEEN={
            tweens:[],
            update:function(){
                this.tweens.forEach((t,e)=>{if(t.update())this.tweens.splice(e,1)})
            },
            Tween:function(t){
                this.target=t;
                this.to=function(t,e){
                    this.vals=t;
                    this.dur=e;
                    return this;
                };
                this.start=function(){
                    this.startVals={};
                    for(let e in this.vals) this.startVals[e]=this.target[e];
                    this.startTime=performance.now();
                    this.started=true;
                    TWEEN.tweens.push(this);
                    return this;
                };
                this.update=function(){
                    if(!this.started)return false;
                    const t=Math.min((performance.now()-this.startTime)/this.dur,1);
                    let e=t;
                    if(this.ease) e=this.ease(t);
                    else e=t*(2-t);
                    for(let s in this.vals) this.target[s]=this.startVals[s]+(this.vals[s]-this.startVals[s])*e;
                    if(t>=1) {
                        if(this.complete) this.complete();
                        if(this.next) this.next.start();
                        return true;
                    }
                    return false;
                };
                this.easing=function(fn){ this.ease=fn; return this; };
                this.chain=function(t){ this.next=t; return this; };
                this.onComplete=function(fn){ this.complete=fn; return this; };
            },
            Easing:{
                Elastic:{Out:function(t){return 0===t?0:1===t?1:Math.pow(2,-10*t)*Math.sin((t-0.075)*(2*Math.PI)/0.3)+1}},
                Bounce:{Out:function(t){return t<1/2.75?7.5625*t*t:t<2/2.75?7.5625*(t-=1.5/2.75)*t+.75:t<2.5/2.75?7.5625*(t-=2.25/2.75)*t+.9375:7.5625*(t-=2.625/2.75)*t+.984375}}
            }
        };

        init();
    </script>
</body>
</html>
